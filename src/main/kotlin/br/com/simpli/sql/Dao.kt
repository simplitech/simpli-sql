package br.com.simpli.sql

import br.com.simpli.model.EnglishLanguage
import br.com.simpli.model.LanguageHolder
import br.com.simpli.model.RespException
import java.sql.Connection
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.sql.SQLException
import java.sql.Statement
import java.util.*
import java.util.logging.Level
import java.util.logging.Logger

/**
 * Executes the Queries
 *
 * @author gil
 */
open class Dao(protected var con: Connection, protected var lang: LanguageHolder) {

    val q get() = Query()

    protected fun execute(query: Query): GenericResult {

        var statem: PreparedStatement? = null
        val genResult = GenericResult()
        var keys: ResultSet? = null
        try {
            statem = prepareStatement(con, Statement.RETURN_GENERATED_KEYS, query.strSt, *query.paramsSt.toTypedArray())
            genResult.affectedRows = statem.executeUpdate()

            keys = statem.generatedKeys

            if (keys.next()) {
                genResult.key = keys.getLong(1)
            }
            closeStatementAndResult(statem, keys)
        } catch (ex: Exception) {
            Logger.getLogger(Dao::class.java.name).log(Level.INFO, statem.toString())
            closeStatementAndResult(statem, keys)
            val re = RespException(lang.unexpectedError())
            re.initCause(ex)
            throw re
        }

        return genResult

    }


    protected fun <T> getResp(query: Query, callback: (rs: ResultSet) -> T): T {

        var statem: PreparedStatement? = null
        var rs: ResultSet? = null
        var result: T?

        try {
            statem = prepareStatement(con, null, query.strSt, *query.paramsSt.toTypedArray())
            rs = statem.executeQuery()

            result = callback(rs)
            closeStatementAndResult(statem, rs)
        } catch (ex: Exception) {
            Logger.getLogger(Dao::class.java.name).log(Level.INFO, statem.toString())
            closeStatementAndResult(statem, rs)
            val re = RespException(lang.unexpectedError())
            re.initCause(ex)
            throw re
        }

        return result

    }

    protected fun <T> getList(query: Query, callback: (rs: ResultSet) -> T) = getResp(query) {
        val result = LinkedList<T>()

        while (it.next()) {
            result.add(callback(it))
        }

        result
    }

    protected fun <T> getOne(query: Query, callback: (rs: ResultSet) -> T): T? = getResp(query) {
        if (it.next()) callback(it) else null
    }

    protected fun exist(query: Query) = getResp(query) { it.next() }

    protected fun getFirstInt(query: Query) = getOne(query) { it.getIntOrNull(1) }
    protected fun getIntList(query: Query) = getList(query) { it.getIntOrNull(1) }

    protected fun getFirstLong(query: Query) = getOne(query) { it.getLongOrNull(1) }
    protected fun getLongList(query: Query) = getList(query) { it.getLongOrNull(1) }

    protected fun getFirstDouble(query: Query) = getOne(query) { it.getDoubleOrNull(1) }
    protected fun getDoubleList(query: Query) = getList(query) { it.getDoubleOrNull(1) }

    protected fun getFirstString(query: Query) = getOne(query) { it.getString(1) }
    protected fun getStringList(query: Query) = getList(query) { it.getString(1) }

    protected fun getFirstDate(query: Query) = getOne(query) { it.getTimestamp(1) }
    protected fun getDateList(query: Query) = getList(query) { it.getTimestamp(1) }

    protected fun getFirstBoolean(query: Query) = getOne(query) { it.getBooleanOrNull(1) }
    protected fun getBooleanList(query: Query) = getList(query) { it.getBooleanOrNull(1) }

    /**
     * prepare the statement
     *
     * @param con connection to be used
     * @param strStatement your query with ? for the variables
     * @param objStatement variables that will replace the ?
     * @return the prepared statement
     * @throws SQLException if (1) couldn't get the connection; (2) coudn't
     * prepare the statement; (3) coudn't understand the object
     */
    @Throws(SQLException::class)
    protected fun prepareStatement(con: Connection, autoGeneratedKeys: Int?, strStatement: String, vararg objStatement: Any?): PreparedStatement {
        val statem = if (autoGeneratedKeys != null) {
            con.prepareStatement(strStatement, autoGeneratedKeys)
        } else {
            con.prepareStatement(strStatement)
        }

        var i = 1
        for (o in objStatement) {
            var os = o

            if (os != null && os.javaClass == Date::class.java) {
                os = java.sql.Timestamp((os as Date).time)
            }

            statem.setObject(i, os)
            i++
        }

        return statem
    }

    /**
     * closes the statement and resultset
     *
     * @param pstmt
     * @param rs
     */
    protected fun closeStatementAndResult(pstmt: PreparedStatement?, rs: ResultSet?) {

        if (rs != null) {
            try {
                rs.close()
            } catch (ex: Exception) {
                try {
                    Logger.getLogger(Dao::class.java.name).log(Level.SEVERE, ex.message, ex)
                } catch (ex2: Exception) {
                }

            }

        }

        if (pstmt != null) {
            try {
                pstmt.close()
            } catch (ex: Exception) {
                try {
                    Logger.getLogger(Dao::class.java.name).log(Level.SEVERE, ex.message, ex)
                } catch (ex2: Exception) {
                }

            }

        }
    }

    /**
     * result of the execute. affectedRows is the amount of affected rows; key id
     * the id of the insert;
     */
    inner class GenericResult {
        var affectedRows: Int = 0
        var key: Long = 0
    }

    companion object {
        fun executeForTest(con: Connection, query: Query): GenericResult {
            return Dao(con, EnglishLanguage()).execute(query)
        }

        fun existForTest(con: Connection, query: Query): Boolean {
            return Dao(con, EnglishLanguage()).exist(query)
        }
    }

}