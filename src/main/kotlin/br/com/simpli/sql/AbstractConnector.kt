package br.com.simpli.sql

import br.com.simpli.model.EnglishLanguage
import br.com.simpli.model.LanguageHolder
import br.com.simpli.model.RespException
import java.sql.Connection
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.sql.SQLException
import java.util.*
import java.util.logging.Level
import java.util.logging.Logger

/**
 * Executes the Queries
 *
 * @author gil
 */
abstract class AbstractConnector(protected var con: Connection) {

    var lang: LanguageHolder = EnglishLanguage()

    abstract fun execute(query: Query): GenericResult

    fun <T> getResp(query: Query, callback: (rs: ResultSet) -> T): T {

        var statem: PreparedStatement? = null
        var rs: ResultSet? = null
        val result: T?

        try {
            statem = prepareStatement(con, null, query.strSt, *query.paramsSt.toTypedArray())
            rs = statem.executeQuery()

            result = callback(rs)
            closeStatementAndResult(statem, rs)
        } catch (ex: Exception) {
            Logger.getLogger(AbstractConnector::class.java.name).log(Level.INFO, statem.toString())
            closeStatementAndResult(statem, rs)
            val re = RespException(lang.unexpectedError())
            re.initCause(ex)
            throw re
        }

        return result

    }

    fun <T> getList(query: Query, callback: (rs: ResultSet) -> T) = getResp(query) {
        val result = LinkedList<T>()

        while (it.next()) {
            result.add(callback(it))
        }

        result
    }

    fun <T> getOne(query: Query, callback: (rs: ResultSet) -> T): T? = getResp(query) {
        if (it.next()) callback(it) else null
    }

    fun exist(query: Query) = getResp(query) { it.next() }

    fun getFirstInt(query: Query) = getOne(query) { it.getIntOrNull(1) }
    fun getIntList(query: Query) = getList(query) { it.getIntOrNull(1) }
    fun getFirstLong(query: Query) = getOne(query) { it.getLongOrNull(1) }
    fun getLongList(query: Query) = getList(query) { it.getLongOrNull(1) }
    fun getFirstDouble(query: Query) = getOne(query) { it.getDoubleOrNull(1) }
    fun getDoubleList(query: Query) = getList(query) { it.getDoubleOrNull(1) }
    fun getFirstString(query: Query) = getOne(query) { it.getString(1) }
    fun getStringList(query: Query) = getList(query) { it.getString(1) }
    fun getFirstDate(query: Query) = getOne(query) { it.getTimestamp(1) }
    fun getDateList(query: Query) = getList(query) { it.getTimestamp(1) }
    fun getFirstBoolean(query: Query) = getOne(query) { it.getBooleanOrNull(1) }
    fun getBooleanList(query: Query) = getList(query) { it.getBooleanOrNull(1) }

    /**
     * prepare the statement
     *
     * @param con connection to be used
     * @param strStatement your query with ? for the variables
     * @param objStatement variables that will replace the ?
     * @return the prepared statement
     * @throws SQLException if (1) couldn't get the connection; (2) coudn't
     * prepare the statement; (3) coudn't understand the object
     */
    @Throws(SQLException::class)
    protected fun prepareStatement(con: Connection, autoGeneratedKeys: Int?, strStatement: String, vararg objStatement: Any?): PreparedStatement {
        val statem = if (autoGeneratedKeys != null) {
            con.prepareStatement(strStatement, autoGeneratedKeys)
        } else {
            con.prepareStatement(strStatement)
        }

        var i = 1
        for (o in objStatement) {
            var os = o

            if (os != null && os.javaClass == Date::class.java) {
                os = java.sql.Timestamp((os as Date).time)
            }

            statem.setObject(i, os)
            i++
        }

        return statem
    }

    /**
     * closes the statement and resultset
     *
     * @param pstmt
     * @param rs
     */
    protected fun closeStatementAndResult(pstmt: PreparedStatement?, rs: ResultSet?) {

        if (rs != null) {
            try {
                rs.close()
            } catch (ex: Exception) {
                try {
                    Logger.getLogger(AbstractConnector::class.java.name).log(Level.SEVERE, ex.message, ex)
                } catch (ex2: Exception) {
                }

            }

        }

        if (pstmt != null) {
            try {
                pstmt.close()
            } catch (ex: Exception) {
                try {
                    Logger.getLogger(AbstractConnector::class.java.name).log(Level.SEVERE, ex.message, ex)
                } catch (ex2: Exception) {
                }

            }

        }
    }

    /**
     * result of the execute. affectedRows is the amount of affected rows; key id
     * the id of the insert;
     */
    inner class GenericResult {
        var affectedRows: Int = 0
        var key: Long = 0
    }

}