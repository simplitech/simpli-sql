package br.com.simpli.sql

import br.com.simpli.model.EnglishLanguage
import br.com.simpli.model.LanguageHolder
import br.com.simpli.model.RespException
import com.mysql.jdbc.MysqlErrorNumbers
import java.sql.Connection
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.sql.SQLException
import java.util.*
import java.util.logging.Level
import java.util.logging.Logger

/**
 * Executes the Queries
 *
 * @author gil
 */
abstract class AbstractConnector(
        protected var con: Connection,
        private val deadlockRetries: Int,
        private val deadlockWait: Long
) {
    companion object {
        const val DEFAULT_DEADLOCK_RETRIES = 5
        const val DEFAULT_DEADLOCK_WAIT = 1000L
    }

    var lang: LanguageHolder = EnglishLanguage()

    abstract fun execute(query: Query): GenericResult

    protected fun <T> handleOperation(
            query: Query,
            autoGeneratedKeys: Int? = null,
            createResultAndResultSet: (preparedStatement: PreparedStatement) -> ResultAndResultSet<T>
    ): T {
        var deadlockRetries = this.deadlockRetries
        var deadlockExp = false
        var exception: Exception?

        do {
            var statem: PreparedStatement? = null
            var rs: ResultSet? = null

            try {
                statem = prepareStatement(con, autoGeneratedKeys, query.strSt, *query.paramsSt.toTypedArray())
                val resultAndResultSet = createResultAndResultSet(statem)
                rs = resultAndResultSet.resultSet
                return resultAndResultSet.result
            } catch (ex: Exception) {
                if (ex is SQLException && ex.errorCode == MysqlErrorNumbers.ER_LOCK_DEADLOCK) {
                    deadlockExp = true
                    Thread.sleep(this.deadlockWait)
                } else {
                    Logger.getLogger(AbstractConnector::class.java.name).log(Level.INFO, statem.toString())
                }
                exception = ex
            }
            finally {
                closeStatementAndResultSet(statem, rs)
            }
        } while (deadlockExp && deadlockRetries-- > 0)

        val re = RespException(lang.unexpectedError())
        re.initCause(exception)
        throw re
    }

    fun <T> getResp(query: Query, callback: (rs: ResultSet) -> T) = handleOperation(query) {
        val rs = it.executeQuery()
        ResultAndResultSet(callback(rs), rs)
    }

    fun <T> getList(query: Query, callback: (rs: ResultSet) -> T) = getResp(query) {
        val result = LinkedList<T>()

        while (it.next()) {
            result.add(callback(it))
        }

        result
    }

    fun <T> getOne(query: Query, callback: (rs: ResultSet) -> T): T? = getResp(query) {
        if (it.next()) callback(it) else null
    }

    fun exist(query: Query) = getResp(query) { it.next() }

    fun getFirstInt(query: Query) = getOne(query) { it.getIntOrNull(1) }
    fun getIntList(query: Query) = getList(query) { it.getIntOrNull(1) }
    fun getFirstLong(query: Query) = getOne(query) { it.getLongOrNull(1) }
    fun getLongList(query: Query) = getList(query) { it.getLongOrNull(1) }
    fun getFirstDouble(query: Query) = getOne(query) { it.getDoubleOrNull(1) }
    fun getDoubleList(query: Query) = getList(query) { it.getDoubleOrNull(1) }
    fun getFirstString(query: Query) = getOne(query) { it.getString(1) }
    fun getStringList(query: Query) = getList(query) { it.getString(1) }
    fun getFirstDate(query: Query) = getOne(query) { it.getTimestamp(1) }
    fun getDateList(query: Query) = getList(query) { it.getTimestamp(1) }
    fun getFirstBoolean(query: Query) = getOne(query) { it.getBooleanOrNull(1) }
    fun getBooleanList(query: Query) = getList(query) { it.getBooleanOrNull(1) }

    /**
     * prepare the statement
     *
     * @param con connection to be used
     * @param strStatement your query with ? for the variables
     * @param objStatement variables that will replace the ?
     * @return the prepared statement
     * @throws SQLException if (1) couldn't get the connection; (2) coudn't
     * prepare the statement; (3) coudn't understand the object
     */
    @Throws(SQLException::class)
    protected fun prepareStatement(
            con: Connection,
            autoGeneratedKeys: Int?,
            strStatement: String,
            vararg objStatement: Any?
    ): PreparedStatement {
        val statem = if (autoGeneratedKeys != null) {
            con.prepareStatement(strStatement, autoGeneratedKeys)
        } else {
            con.prepareStatement(strStatement)
        }

        var i = 1
        for (o in objStatement) {
            var os = o

            if (os != null && os.javaClass == Date::class.java) {
                os = java.sql.Timestamp((os as Date).time)
            }

            statem.setObject(i, os)
            i++
        }

        return statem
    }

    /**
     * closes the statement and resultset
     *
     * @param pstmt
     * @param rs
     */
    protected fun closeStatementAndResultSet(pstmt: PreparedStatement?, rs: ResultSet?) {

        if (rs != null) {
            try {
                rs.close()
            } catch (ex: Exception) {
                try {
                    Logger.getLogger(AbstractConnector::class.java.name).log(Level.SEVERE, ex.message, ex)
                } catch (ex2: Exception) {
                }

            }

        }

        if (pstmt != null) {
            try {
                pstmt.close()
            } catch (ex: Exception) {
                try {
                    Logger.getLogger(AbstractConnector::class.java.name).log(Level.SEVERE, ex.message, ex)
                } catch (ex2: Exception) {
                }

            }

        }
    }

    /**
     * result of the execute. affectedRows is the amount of affected rows; key id
     * the id of the insert;
     */
    inner class GenericResult {
        var affectedRows: Int = 0
        var key: Long = 0
    }

    inner class ResultAndResultSet<T>(val result: T, val resultSet: ResultSet)

}
